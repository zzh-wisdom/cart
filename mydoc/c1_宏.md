# Cart 使用的宏的说明

## 宏的简单使用

 CART provides a set of macros for RPC registration. Using the macro interface
 to register RPCs is much simpler and reduces the opportunities for mistakes.

 public macros:

     preparation:
         - CRT_RPC_DECLARE()
         - CRT_RPC_DEFINE()

     registration:
         - CRT_RPC_REGISTER()
         - CRT_RPC_SRV_REGISTER()

 To register an RPC using macros:

 ```c
     CRT_RPC_DECLARE(my_rpc_name, input_fields, output_fields)  // 没有分号
     CRT_RPC_DEFINE(my_rpc_name, input_fields, output_fields)
     CRT_RPC_REGISTER(opcode, flags, my_rpc_name);
 ```
 
 The input/output structs can be accessed using the following pointers:
     struct my_rpc_name_in *rpc_in;
     struct my_rpc_name_out *rpc_out;


 Prepare struct types and format description for the input/output of an RPC.
 Supported types in the fields_in/fields_out list can be found in
 include/cart/types.h

 Example usage:

 \#define CRT_ISEQ_MY_RPC
     ((int32_t)       (mr_arg_1)     CRT_VAR)
     ((uint32_t)      (mr_arg_2)     CRT_VAR)
     ((d_rank_t)      (mr_rank)      CRT_VAR)
     ((d_rank_list_t) (mr_rank_list) CRT_PTR)
     ((uuid_t)        (mr_array)     CRT_ARRAY)
     ((d_string_t)    (mr_name)      CRT_VAR)

 \#define CRT_OSEQ_MY_RPC
     ((int32_t)       (mr_ret)       CRT_VAR)

 CRT_RPC_DECLARE(my_rpc, CRT_ISEQ_MY_RPC, CRT_OSEQ_MY_RPC)
 CRT_RPC_REGISTER(opcode, flags, my_rpc);

 these two macros above expands into:

 struct my_rpc_in {
     int32_t           mr_arg_1;
     uint32_t          mr_arg_2;
     d_rank_t          mr_rank;
     d_rank_list_t    *mr_rank_list;
     struct crt_array  mr_array;
     d_string_t        mr_name;
 };

 struct my_rpc_out {
     int32_t           mr_ret;
 };

 crt_register(opcode, flags, &CQF_my_rpc);

 the macros CRT_RPC_DEFINE(my_rpc, CRT_ISEQ_MY_RPC, CRT_OSEQ_MY_RPC) expands
 into internal RPC definition which will be used in RPC registration.
 The content of this macro expansion will be changed in the future.

 To use array types it's possible to define types as above, and then use the
 same macros to declare types and proc structs for types, and then reference
 the type directly in the RPC definition.

 CRT_GEN_STRUCT(struct, CRT_SEQ_MY_TYPE)
 CRT_GEN_PROC_FUNC(struct, CRT_SEQ_MY_TYPE)

## 特殊宏的说明

### CRT_RPC_DECLARE

声明一个RPC调用所需的输入输出数据类型：

- [rpc_name]_in: rpc调用[rpc_name]的输入类型
- [rpc_name]_out: rpc调用[rpc_name]的输出类型

另外，还定义了一个处理输入输出编解码的回调函数封装类实例：

```c
struct crt_req_format CQF_[rpc_name];
```

注意，如果一个表达式CRT_ISEQ_URI_LOOKUP定义如下：

```c
#define CRT_VAR   0
#define CRT_ISEQ_URI_LOOKUP	/** input fields */		 \
	((uint32_t)		(ul_tag)		CRT_VAR)

// 定义
CRT_RPC_DECLARE(crt_uri_lookup, CRT_ISEQ_URI_LOOKUP, CRT_OSEQ_URI_LOOKUP)
```

则对应的输入结构体类型并不都是表面以为的那样，即：

```c
struct crt_uri_lookup_in {
    uint32_t ul_tag;
}
```

实际上，结构的定义使用如下宏：

```c
#define CRT_GEN_STRUCT(struct_type_name, seq)				\
	struct struct_type_name {					\
		BOOST_PP_SEQ_FOR_EACH(CRT_GEN_STRUCT_FIELD, , seq)	\
	};
```

实际上每个字段都有四种类型：

- #define CRT_VAR   0  
- #define CRT_PTR   1
- #define CRT_ARRAY 2
- #define CRT_RAW   3

上面的使用示例中，在每种类型定义下得到的数据类型分别如下：

1. CRT_VAR

```c
struct crt_uri_lookup_in {
    uint32_t ul_tag;
}
```

2. CRT_PTR

```c
struct crt_uri_lookup_in {
    uint32_t *ul_tag;
}
```

3. CRT_ARRAY

```c
struct crt_uri_lookup_in {
    struct {
        uint64_t ca_count;
        uint32_t *ca_arrays;
    } ul_tag;
};
```

4. CRT_RAW 

同第1个，但类型为语言的**原生类型**。

### CRT_RPC_DEFINE

为输入输入定义回调函数(编解码处理函数)：

- crt_proc_struct_[rpc_name]_in
- crt_proc_struct_[rpc_name]_out

初始化对象 CQF_[rpc_name]。该对象中的编解码函数就是上述定义的。
